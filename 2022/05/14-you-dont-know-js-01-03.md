# You Don’t Know JS 📚 1장~3장. 타입과 문법, 값, 네이티브

## 3줄 요약

- undefined(값이 없는) undeclared(선언되지 않은) 완전히 다르지만 typeof에는 독특한 안전 가드로 에러가 발생하지 않는다.
- `원시 값은 '박싱' 과정`을 거친다. 원시 값에는 프로퍼티나 메소드가 없다. 자바스크립트는 원시 값을 알아서 박싱해 준다.(.length, .toUpperCase,..)
- new 키워드를 붙여 객체 래퍼로 `직접 박싱`하면 truthy한 객체로 된다.

## 책에서 기억하고 싶은 내용을 써보세요.

**1장**

- 내장 타입: `null, undefined, boolean, number, string, object, symbol`
- function, array: object의 하위 타입(호출 가능한 객체 [[Call]])
- typeof 연산자: 이 변수에 들어있는 값의 타입은 무엇이니?
- undefined(값이 없는) undeclared(선언되지 않은) 완전히 다르지만 typeof에는 독특한 안전 가드로 에러가 발생하지 않는다.

2장

- 유사 배열을 배열로 바꾸고 싶을 때: Array.from() 사용
- 문자열은 문자 배열과 같지 않지만, 겉모습(indexOf, concat) 이 닮았다. (문자열 = 유사 배열)
    - 문자열: 불변 값. 문자열 메소드는 항상 새로운 문자열을 생성한다. 따라서 배열의 가변 메서드는 빌려 쓰는 것도 안된다.
    - 배열: 가변 값
- NaN: 유효하지 않은 숫자, 실패한 숫자, 몹쓸 숫자, 자기 자신과도 같지 않은 유일한 값 (NaN !== NaN)
- 값 복사: 원시 값은 언제나. 오직 자신의 값만 가리킴.
- 레퍼런스 복사: 객체, 함수는 합성 값은 할당/전달 시 반드시. 값 복사로 전달하려면 값의 사본을 만들어 전달해야 함
- 자바스크립트에서는 어떤 변수가 다른 변수를 참조할 수 없다.

3장

- Object.prototype.toString.call(object) 호출 시 [object {내부 [[Class]] 값}] 형태로 내장 네이티브 생성자를 알 수 있다.
    - `원시 값은 '박싱' 과정`을 거친다. 원시 값에는 프로퍼티나 메소드가 없다. 자바스크립트는 원시 값을 알아서 박싱해 준다.(.length, .toUpperCase,..) 개발자가 객체 형태로 바꿔버리는 경우 더 느려질 수 있다.
    - new Boolean(false): new 키워드를 붙여 객체 래퍼로 `직접 박싱`하면 truthy한 객체로 된다.
    <img width="240" alt="Screen Shot 2022-05-14 at 10 00 32 PM" src="https://user-images.githubusercontent.com/30427711/168426832-019f4402-42ac-4c3f-aa13-7e82cd6a44f4.png">

- RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있다.
- error 객체의 주 용도는 현재의 실행 스택 콘텍스트를 포착하여 객체에 담는 것이다.
- 네이티브 프로토타입(.prototype 객체는 하위 타입별로 고유한 로직이 있다.)
    - 프로토타입 위임 덕분에 모든 문자열이 메서드를 같이 쓸 수 있다.
    - 어떤 식으로든 프로토타입을 변경하지 않도록 유의한다.

## 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요

- Array, String의 경우 new 를 사용하지 않는다는 것은 알고 있었지만 박싱 과정을 거쳐서 보통의 예상과는 다른 결과가 나온다는 것을 알게 되었다.
- 자바스크립트가 타입을 돌아가는 원리에 대해 더 잘 이해하게 되었다.
